// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'generator_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$GeneratorState {
  String get generatedPassword => throw _privateConstructorUsedError;
  int get length => throw _privateConstructorUsedError;
  bool get lowercase => throw _privateConstructorUsedError;
  bool get uppercase => throw _privateConstructorUsedError;
  bool get numbers => throw _privateConstructorUsedError;
  bool get symbols => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $GeneratorStateCopyWith<GeneratorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GeneratorStateCopyWith<$Res> {
  factory $GeneratorStateCopyWith(
          GeneratorState value, $Res Function(GeneratorState) then) =
      _$GeneratorStateCopyWithImpl<$Res, GeneratorState>;
  @useResult
  $Res call(
      {String generatedPassword,
      int length,
      bool lowercase,
      bool uppercase,
      bool numbers,
      bool symbols});
}

/// @nodoc
class _$GeneratorStateCopyWithImpl<$Res, $Val extends GeneratorState>
    implements $GeneratorStateCopyWith<$Res> {
  _$GeneratorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? generatedPassword = null,
    Object? length = null,
    Object? lowercase = null,
    Object? uppercase = null,
    Object? numbers = null,
    Object? symbols = null,
  }) {
    return _then(_value.copyWith(
      generatedPassword: null == generatedPassword
          ? _value.generatedPassword
          : generatedPassword // ignore: cast_nullable_to_non_nullable
              as String,
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int,
      lowercase: null == lowercase
          ? _value.lowercase
          : lowercase // ignore: cast_nullable_to_non_nullable
              as bool,
      uppercase: null == uppercase
          ? _value.uppercase
          : uppercase // ignore: cast_nullable_to_non_nullable
              as bool,
      numbers: null == numbers
          ? _value.numbers
          : numbers // ignore: cast_nullable_to_non_nullable
              as bool,
      symbols: null == symbols
          ? _value.symbols
          : symbols // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_GeneratorStateCopyWith<$Res>
    implements $GeneratorStateCopyWith<$Res> {
  factory _$$_GeneratorStateCopyWith(
          _$_GeneratorState value, $Res Function(_$_GeneratorState) then) =
      __$$_GeneratorStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String generatedPassword,
      int length,
      bool lowercase,
      bool uppercase,
      bool numbers,
      bool symbols});
}

/// @nodoc
class __$$_GeneratorStateCopyWithImpl<$Res>
    extends _$GeneratorStateCopyWithImpl<$Res, _$_GeneratorState>
    implements _$$_GeneratorStateCopyWith<$Res> {
  __$$_GeneratorStateCopyWithImpl(
      _$_GeneratorState _value, $Res Function(_$_GeneratorState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? generatedPassword = null,
    Object? length = null,
    Object? lowercase = null,
    Object? uppercase = null,
    Object? numbers = null,
    Object? symbols = null,
  }) {
    return _then(_$_GeneratorState(
      generatedPassword: null == generatedPassword
          ? _value.generatedPassword
          : generatedPassword // ignore: cast_nullable_to_non_nullable
              as String,
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int,
      lowercase: null == lowercase
          ? _value.lowercase
          : lowercase // ignore: cast_nullable_to_non_nullable
              as bool,
      uppercase: null == uppercase
          ? _value.uppercase
          : uppercase // ignore: cast_nullable_to_non_nullable
              as bool,
      numbers: null == numbers
          ? _value.numbers
          : numbers // ignore: cast_nullable_to_non_nullable
              as bool,
      symbols: null == symbols
          ? _value.symbols
          : symbols // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_GeneratorState extends _GeneratorState {
  const _$_GeneratorState(
      {required this.generatedPassword,
      required this.length,
      required this.lowercase,
      required this.uppercase,
      required this.numbers,
      required this.symbols})
      : super._();

  @override
  final String generatedPassword;
  @override
  final int length;
  @override
  final bool lowercase;
  @override
  final bool uppercase;
  @override
  final bool numbers;
  @override
  final bool symbols;

  @override
  String toString() {
    return 'GeneratorState(generatedPassword: $generatedPassword, length: $length, lowercase: $lowercase, uppercase: $uppercase, numbers: $numbers, symbols: $symbols)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_GeneratorState &&
            (identical(other.generatedPassword, generatedPassword) ||
                other.generatedPassword == generatedPassword) &&
            (identical(other.length, length) || other.length == length) &&
            (identical(other.lowercase, lowercase) ||
                other.lowercase == lowercase) &&
            (identical(other.uppercase, uppercase) ||
                other.uppercase == uppercase) &&
            (identical(other.numbers, numbers) || other.numbers == numbers) &&
            (identical(other.symbols, symbols) || other.symbols == symbols));
  }

  @override
  int get hashCode => Object.hash(runtimeType, generatedPassword, length,
      lowercase, uppercase, numbers, symbols);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GeneratorStateCopyWith<_$_GeneratorState> get copyWith =>
      __$$_GeneratorStateCopyWithImpl<_$_GeneratorState>(this, _$identity);
}

abstract class _GeneratorState extends GeneratorState {
  const factory _GeneratorState(
      {required final String generatedPassword,
      required final int length,
      required final bool lowercase,
      required final bool uppercase,
      required final bool numbers,
      required final bool symbols}) = _$_GeneratorState;
  const _GeneratorState._() : super._();

  @override
  String get generatedPassword;
  @override
  int get length;
  @override
  bool get lowercase;
  @override
  bool get uppercase;
  @override
  bool get numbers;
  @override
  bool get symbols;
  @override
  @JsonKey(ignore: true)
  _$$_GeneratorStateCopyWith<_$_GeneratorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$GeneratorEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int length) lengthChanged,
    required TResult Function(bool lowercase) lowercaseChanged,
    required TResult Function(bool uppercase) uppercaseChanged,
    required TResult Function(bool numbers) numbersChanged,
    required TResult Function(bool symbols) symbolsChanged,
    required TResult Function() regeneratePassword,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int length)? lengthChanged,
    TResult? Function(bool lowercase)? lowercaseChanged,
    TResult? Function(bool uppercase)? uppercaseChanged,
    TResult? Function(bool numbers)? numbersChanged,
    TResult? Function(bool symbols)? symbolsChanged,
    TResult? Function()? regeneratePassword,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int length)? lengthChanged,
    TResult Function(bool lowercase)? lowercaseChanged,
    TResult Function(bool uppercase)? uppercaseChanged,
    TResult Function(bool numbers)? numbersChanged,
    TResult Function(bool symbols)? symbolsChanged,
    TResult Function()? regeneratePassword,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LengthChangedEvent value) lengthChanged,
    required TResult Function(LowercaseChangedEvent value) lowercaseChanged,
    required TResult Function(UppercaseChangedEvent value) uppercaseChanged,
    required TResult Function(NumbersChangedEvent value) numbersChanged,
    required TResult Function(SymbolsChangedEvent value) symbolsChanged,
    required TResult Function(RegeneratePasswordEvent value) regeneratePassword,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LengthChangedEvent value)? lengthChanged,
    TResult? Function(LowercaseChangedEvent value)? lowercaseChanged,
    TResult? Function(UppercaseChangedEvent value)? uppercaseChanged,
    TResult? Function(NumbersChangedEvent value)? numbersChanged,
    TResult? Function(SymbolsChangedEvent value)? symbolsChanged,
    TResult? Function(RegeneratePasswordEvent value)? regeneratePassword,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LengthChangedEvent value)? lengthChanged,
    TResult Function(LowercaseChangedEvent value)? lowercaseChanged,
    TResult Function(UppercaseChangedEvent value)? uppercaseChanged,
    TResult Function(NumbersChangedEvent value)? numbersChanged,
    TResult Function(SymbolsChangedEvent value)? symbolsChanged,
    TResult Function(RegeneratePasswordEvent value)? regeneratePassword,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GeneratorEventCopyWith<$Res> {
  factory $GeneratorEventCopyWith(
          GeneratorEvent value, $Res Function(GeneratorEvent) then) =
      _$GeneratorEventCopyWithImpl<$Res, GeneratorEvent>;
}

/// @nodoc
class _$GeneratorEventCopyWithImpl<$Res, $Val extends GeneratorEvent>
    implements $GeneratorEventCopyWith<$Res> {
  _$GeneratorEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LengthChangedEventCopyWith<$Res> {
  factory _$$LengthChangedEventCopyWith(_$LengthChangedEvent value,
          $Res Function(_$LengthChangedEvent) then) =
      __$$LengthChangedEventCopyWithImpl<$Res>;
  @useResult
  $Res call({int length});
}

/// @nodoc
class __$$LengthChangedEventCopyWithImpl<$Res>
    extends _$GeneratorEventCopyWithImpl<$Res, _$LengthChangedEvent>
    implements _$$LengthChangedEventCopyWith<$Res> {
  __$$LengthChangedEventCopyWithImpl(
      _$LengthChangedEvent _value, $Res Function(_$LengthChangedEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? length = null,
  }) {
    return _then(_$LengthChangedEvent(
      null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LengthChangedEvent implements LengthChangedEvent {
  const _$LengthChangedEvent(this.length);

  @override
  final int length;

  @override
  String toString() {
    return 'GeneratorEvent.lengthChanged(length: $length)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LengthChangedEvent &&
            (identical(other.length, length) || other.length == length));
  }

  @override
  int get hashCode => Object.hash(runtimeType, length);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LengthChangedEventCopyWith<_$LengthChangedEvent> get copyWith =>
      __$$LengthChangedEventCopyWithImpl<_$LengthChangedEvent>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int length) lengthChanged,
    required TResult Function(bool lowercase) lowercaseChanged,
    required TResult Function(bool uppercase) uppercaseChanged,
    required TResult Function(bool numbers) numbersChanged,
    required TResult Function(bool symbols) symbolsChanged,
    required TResult Function() regeneratePassword,
  }) {
    return lengthChanged(length);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int length)? lengthChanged,
    TResult? Function(bool lowercase)? lowercaseChanged,
    TResult? Function(bool uppercase)? uppercaseChanged,
    TResult? Function(bool numbers)? numbersChanged,
    TResult? Function(bool symbols)? symbolsChanged,
    TResult? Function()? regeneratePassword,
  }) {
    return lengthChanged?.call(length);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int length)? lengthChanged,
    TResult Function(bool lowercase)? lowercaseChanged,
    TResult Function(bool uppercase)? uppercaseChanged,
    TResult Function(bool numbers)? numbersChanged,
    TResult Function(bool symbols)? symbolsChanged,
    TResult Function()? regeneratePassword,
    required TResult orElse(),
  }) {
    if (lengthChanged != null) {
      return lengthChanged(length);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LengthChangedEvent value) lengthChanged,
    required TResult Function(LowercaseChangedEvent value) lowercaseChanged,
    required TResult Function(UppercaseChangedEvent value) uppercaseChanged,
    required TResult Function(NumbersChangedEvent value) numbersChanged,
    required TResult Function(SymbolsChangedEvent value) symbolsChanged,
    required TResult Function(RegeneratePasswordEvent value) regeneratePassword,
  }) {
    return lengthChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LengthChangedEvent value)? lengthChanged,
    TResult? Function(LowercaseChangedEvent value)? lowercaseChanged,
    TResult? Function(UppercaseChangedEvent value)? uppercaseChanged,
    TResult? Function(NumbersChangedEvent value)? numbersChanged,
    TResult? Function(SymbolsChangedEvent value)? symbolsChanged,
    TResult? Function(RegeneratePasswordEvent value)? regeneratePassword,
  }) {
    return lengthChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LengthChangedEvent value)? lengthChanged,
    TResult Function(LowercaseChangedEvent value)? lowercaseChanged,
    TResult Function(UppercaseChangedEvent value)? uppercaseChanged,
    TResult Function(NumbersChangedEvent value)? numbersChanged,
    TResult Function(SymbolsChangedEvent value)? symbolsChanged,
    TResult Function(RegeneratePasswordEvent value)? regeneratePassword,
    required TResult orElse(),
  }) {
    if (lengthChanged != null) {
      return lengthChanged(this);
    }
    return orElse();
  }
}

abstract class LengthChangedEvent implements GeneratorEvent {
  const factory LengthChangedEvent(final int length) = _$LengthChangedEvent;

  int get length;
  @JsonKey(ignore: true)
  _$$LengthChangedEventCopyWith<_$LengthChangedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LowercaseChangedEventCopyWith<$Res> {
  factory _$$LowercaseChangedEventCopyWith(_$LowercaseChangedEvent value,
          $Res Function(_$LowercaseChangedEvent) then) =
      __$$LowercaseChangedEventCopyWithImpl<$Res>;
  @useResult
  $Res call({bool lowercase});
}

/// @nodoc
class __$$LowercaseChangedEventCopyWithImpl<$Res>
    extends _$GeneratorEventCopyWithImpl<$Res, _$LowercaseChangedEvent>
    implements _$$LowercaseChangedEventCopyWith<$Res> {
  __$$LowercaseChangedEventCopyWithImpl(_$LowercaseChangedEvent _value,
      $Res Function(_$LowercaseChangedEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? lowercase = null,
  }) {
    return _then(_$LowercaseChangedEvent(
      null == lowercase
          ? _value.lowercase
          : lowercase // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$LowercaseChangedEvent implements LowercaseChangedEvent {
  const _$LowercaseChangedEvent(this.lowercase);

  @override
  final bool lowercase;

  @override
  String toString() {
    return 'GeneratorEvent.lowercaseChanged(lowercase: $lowercase)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LowercaseChangedEvent &&
            (identical(other.lowercase, lowercase) ||
                other.lowercase == lowercase));
  }

  @override
  int get hashCode => Object.hash(runtimeType, lowercase);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LowercaseChangedEventCopyWith<_$LowercaseChangedEvent> get copyWith =>
      __$$LowercaseChangedEventCopyWithImpl<_$LowercaseChangedEvent>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int length) lengthChanged,
    required TResult Function(bool lowercase) lowercaseChanged,
    required TResult Function(bool uppercase) uppercaseChanged,
    required TResult Function(bool numbers) numbersChanged,
    required TResult Function(bool symbols) symbolsChanged,
    required TResult Function() regeneratePassword,
  }) {
    return lowercaseChanged(lowercase);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int length)? lengthChanged,
    TResult? Function(bool lowercase)? lowercaseChanged,
    TResult? Function(bool uppercase)? uppercaseChanged,
    TResult? Function(bool numbers)? numbersChanged,
    TResult? Function(bool symbols)? symbolsChanged,
    TResult? Function()? regeneratePassword,
  }) {
    return lowercaseChanged?.call(lowercase);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int length)? lengthChanged,
    TResult Function(bool lowercase)? lowercaseChanged,
    TResult Function(bool uppercase)? uppercaseChanged,
    TResult Function(bool numbers)? numbersChanged,
    TResult Function(bool symbols)? symbolsChanged,
    TResult Function()? regeneratePassword,
    required TResult orElse(),
  }) {
    if (lowercaseChanged != null) {
      return lowercaseChanged(lowercase);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LengthChangedEvent value) lengthChanged,
    required TResult Function(LowercaseChangedEvent value) lowercaseChanged,
    required TResult Function(UppercaseChangedEvent value) uppercaseChanged,
    required TResult Function(NumbersChangedEvent value) numbersChanged,
    required TResult Function(SymbolsChangedEvent value) symbolsChanged,
    required TResult Function(RegeneratePasswordEvent value) regeneratePassword,
  }) {
    return lowercaseChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LengthChangedEvent value)? lengthChanged,
    TResult? Function(LowercaseChangedEvent value)? lowercaseChanged,
    TResult? Function(UppercaseChangedEvent value)? uppercaseChanged,
    TResult? Function(NumbersChangedEvent value)? numbersChanged,
    TResult? Function(SymbolsChangedEvent value)? symbolsChanged,
    TResult? Function(RegeneratePasswordEvent value)? regeneratePassword,
  }) {
    return lowercaseChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LengthChangedEvent value)? lengthChanged,
    TResult Function(LowercaseChangedEvent value)? lowercaseChanged,
    TResult Function(UppercaseChangedEvent value)? uppercaseChanged,
    TResult Function(NumbersChangedEvent value)? numbersChanged,
    TResult Function(SymbolsChangedEvent value)? symbolsChanged,
    TResult Function(RegeneratePasswordEvent value)? regeneratePassword,
    required TResult orElse(),
  }) {
    if (lowercaseChanged != null) {
      return lowercaseChanged(this);
    }
    return orElse();
  }
}

abstract class LowercaseChangedEvent implements GeneratorEvent {
  const factory LowercaseChangedEvent(final bool lowercase) =
      _$LowercaseChangedEvent;

  bool get lowercase;
  @JsonKey(ignore: true)
  _$$LowercaseChangedEventCopyWith<_$LowercaseChangedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UppercaseChangedEventCopyWith<$Res> {
  factory _$$UppercaseChangedEventCopyWith(_$UppercaseChangedEvent value,
          $Res Function(_$UppercaseChangedEvent) then) =
      __$$UppercaseChangedEventCopyWithImpl<$Res>;
  @useResult
  $Res call({bool uppercase});
}

/// @nodoc
class __$$UppercaseChangedEventCopyWithImpl<$Res>
    extends _$GeneratorEventCopyWithImpl<$Res, _$UppercaseChangedEvent>
    implements _$$UppercaseChangedEventCopyWith<$Res> {
  __$$UppercaseChangedEventCopyWithImpl(_$UppercaseChangedEvent _value,
      $Res Function(_$UppercaseChangedEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uppercase = null,
  }) {
    return _then(_$UppercaseChangedEvent(
      null == uppercase
          ? _value.uppercase
          : uppercase // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$UppercaseChangedEvent implements UppercaseChangedEvent {
  const _$UppercaseChangedEvent(this.uppercase);

  @override
  final bool uppercase;

  @override
  String toString() {
    return 'GeneratorEvent.uppercaseChanged(uppercase: $uppercase)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UppercaseChangedEvent &&
            (identical(other.uppercase, uppercase) ||
                other.uppercase == uppercase));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uppercase);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UppercaseChangedEventCopyWith<_$UppercaseChangedEvent> get copyWith =>
      __$$UppercaseChangedEventCopyWithImpl<_$UppercaseChangedEvent>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int length) lengthChanged,
    required TResult Function(bool lowercase) lowercaseChanged,
    required TResult Function(bool uppercase) uppercaseChanged,
    required TResult Function(bool numbers) numbersChanged,
    required TResult Function(bool symbols) symbolsChanged,
    required TResult Function() regeneratePassword,
  }) {
    return uppercaseChanged(uppercase);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int length)? lengthChanged,
    TResult? Function(bool lowercase)? lowercaseChanged,
    TResult? Function(bool uppercase)? uppercaseChanged,
    TResult? Function(bool numbers)? numbersChanged,
    TResult? Function(bool symbols)? symbolsChanged,
    TResult? Function()? regeneratePassword,
  }) {
    return uppercaseChanged?.call(uppercase);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int length)? lengthChanged,
    TResult Function(bool lowercase)? lowercaseChanged,
    TResult Function(bool uppercase)? uppercaseChanged,
    TResult Function(bool numbers)? numbersChanged,
    TResult Function(bool symbols)? symbolsChanged,
    TResult Function()? regeneratePassword,
    required TResult orElse(),
  }) {
    if (uppercaseChanged != null) {
      return uppercaseChanged(uppercase);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LengthChangedEvent value) lengthChanged,
    required TResult Function(LowercaseChangedEvent value) lowercaseChanged,
    required TResult Function(UppercaseChangedEvent value) uppercaseChanged,
    required TResult Function(NumbersChangedEvent value) numbersChanged,
    required TResult Function(SymbolsChangedEvent value) symbolsChanged,
    required TResult Function(RegeneratePasswordEvent value) regeneratePassword,
  }) {
    return uppercaseChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LengthChangedEvent value)? lengthChanged,
    TResult? Function(LowercaseChangedEvent value)? lowercaseChanged,
    TResult? Function(UppercaseChangedEvent value)? uppercaseChanged,
    TResult? Function(NumbersChangedEvent value)? numbersChanged,
    TResult? Function(SymbolsChangedEvent value)? symbolsChanged,
    TResult? Function(RegeneratePasswordEvent value)? regeneratePassword,
  }) {
    return uppercaseChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LengthChangedEvent value)? lengthChanged,
    TResult Function(LowercaseChangedEvent value)? lowercaseChanged,
    TResult Function(UppercaseChangedEvent value)? uppercaseChanged,
    TResult Function(NumbersChangedEvent value)? numbersChanged,
    TResult Function(SymbolsChangedEvent value)? symbolsChanged,
    TResult Function(RegeneratePasswordEvent value)? regeneratePassword,
    required TResult orElse(),
  }) {
    if (uppercaseChanged != null) {
      return uppercaseChanged(this);
    }
    return orElse();
  }
}

abstract class UppercaseChangedEvent implements GeneratorEvent {
  const factory UppercaseChangedEvent(final bool uppercase) =
      _$UppercaseChangedEvent;

  bool get uppercase;
  @JsonKey(ignore: true)
  _$$UppercaseChangedEventCopyWith<_$UppercaseChangedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NumbersChangedEventCopyWith<$Res> {
  factory _$$NumbersChangedEventCopyWith(_$NumbersChangedEvent value,
          $Res Function(_$NumbersChangedEvent) then) =
      __$$NumbersChangedEventCopyWithImpl<$Res>;
  @useResult
  $Res call({bool numbers});
}

/// @nodoc
class __$$NumbersChangedEventCopyWithImpl<$Res>
    extends _$GeneratorEventCopyWithImpl<$Res, _$NumbersChangedEvent>
    implements _$$NumbersChangedEventCopyWith<$Res> {
  __$$NumbersChangedEventCopyWithImpl(
      _$NumbersChangedEvent _value, $Res Function(_$NumbersChangedEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? numbers = null,
  }) {
    return _then(_$NumbersChangedEvent(
      null == numbers
          ? _value.numbers
          : numbers // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$NumbersChangedEvent implements NumbersChangedEvent {
  const _$NumbersChangedEvent(this.numbers);

  @override
  final bool numbers;

  @override
  String toString() {
    return 'GeneratorEvent.numbersChanged(numbers: $numbers)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NumbersChangedEvent &&
            (identical(other.numbers, numbers) || other.numbers == numbers));
  }

  @override
  int get hashCode => Object.hash(runtimeType, numbers);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NumbersChangedEventCopyWith<_$NumbersChangedEvent> get copyWith =>
      __$$NumbersChangedEventCopyWithImpl<_$NumbersChangedEvent>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int length) lengthChanged,
    required TResult Function(bool lowercase) lowercaseChanged,
    required TResult Function(bool uppercase) uppercaseChanged,
    required TResult Function(bool numbers) numbersChanged,
    required TResult Function(bool symbols) symbolsChanged,
    required TResult Function() regeneratePassword,
  }) {
    return numbersChanged(numbers);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int length)? lengthChanged,
    TResult? Function(bool lowercase)? lowercaseChanged,
    TResult? Function(bool uppercase)? uppercaseChanged,
    TResult? Function(bool numbers)? numbersChanged,
    TResult? Function(bool symbols)? symbolsChanged,
    TResult? Function()? regeneratePassword,
  }) {
    return numbersChanged?.call(numbers);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int length)? lengthChanged,
    TResult Function(bool lowercase)? lowercaseChanged,
    TResult Function(bool uppercase)? uppercaseChanged,
    TResult Function(bool numbers)? numbersChanged,
    TResult Function(bool symbols)? symbolsChanged,
    TResult Function()? regeneratePassword,
    required TResult orElse(),
  }) {
    if (numbersChanged != null) {
      return numbersChanged(numbers);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LengthChangedEvent value) lengthChanged,
    required TResult Function(LowercaseChangedEvent value) lowercaseChanged,
    required TResult Function(UppercaseChangedEvent value) uppercaseChanged,
    required TResult Function(NumbersChangedEvent value) numbersChanged,
    required TResult Function(SymbolsChangedEvent value) symbolsChanged,
    required TResult Function(RegeneratePasswordEvent value) regeneratePassword,
  }) {
    return numbersChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LengthChangedEvent value)? lengthChanged,
    TResult? Function(LowercaseChangedEvent value)? lowercaseChanged,
    TResult? Function(UppercaseChangedEvent value)? uppercaseChanged,
    TResult? Function(NumbersChangedEvent value)? numbersChanged,
    TResult? Function(SymbolsChangedEvent value)? symbolsChanged,
    TResult? Function(RegeneratePasswordEvent value)? regeneratePassword,
  }) {
    return numbersChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LengthChangedEvent value)? lengthChanged,
    TResult Function(LowercaseChangedEvent value)? lowercaseChanged,
    TResult Function(UppercaseChangedEvent value)? uppercaseChanged,
    TResult Function(NumbersChangedEvent value)? numbersChanged,
    TResult Function(SymbolsChangedEvent value)? symbolsChanged,
    TResult Function(RegeneratePasswordEvent value)? regeneratePassword,
    required TResult orElse(),
  }) {
    if (numbersChanged != null) {
      return numbersChanged(this);
    }
    return orElse();
  }
}

abstract class NumbersChangedEvent implements GeneratorEvent {
  const factory NumbersChangedEvent(final bool numbers) = _$NumbersChangedEvent;

  bool get numbers;
  @JsonKey(ignore: true)
  _$$NumbersChangedEventCopyWith<_$NumbersChangedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SymbolsChangedEventCopyWith<$Res> {
  factory _$$SymbolsChangedEventCopyWith(_$SymbolsChangedEvent value,
          $Res Function(_$SymbolsChangedEvent) then) =
      __$$SymbolsChangedEventCopyWithImpl<$Res>;
  @useResult
  $Res call({bool symbols});
}

/// @nodoc
class __$$SymbolsChangedEventCopyWithImpl<$Res>
    extends _$GeneratorEventCopyWithImpl<$Res, _$SymbolsChangedEvent>
    implements _$$SymbolsChangedEventCopyWith<$Res> {
  __$$SymbolsChangedEventCopyWithImpl(
      _$SymbolsChangedEvent _value, $Res Function(_$SymbolsChangedEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? symbols = null,
  }) {
    return _then(_$SymbolsChangedEvent(
      null == symbols
          ? _value.symbols
          : symbols // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$SymbolsChangedEvent implements SymbolsChangedEvent {
  const _$SymbolsChangedEvent(this.symbols);

  @override
  final bool symbols;

  @override
  String toString() {
    return 'GeneratorEvent.symbolsChanged(symbols: $symbols)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SymbolsChangedEvent &&
            (identical(other.symbols, symbols) || other.symbols == symbols));
  }

  @override
  int get hashCode => Object.hash(runtimeType, symbols);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SymbolsChangedEventCopyWith<_$SymbolsChangedEvent> get copyWith =>
      __$$SymbolsChangedEventCopyWithImpl<_$SymbolsChangedEvent>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int length) lengthChanged,
    required TResult Function(bool lowercase) lowercaseChanged,
    required TResult Function(bool uppercase) uppercaseChanged,
    required TResult Function(bool numbers) numbersChanged,
    required TResult Function(bool symbols) symbolsChanged,
    required TResult Function() regeneratePassword,
  }) {
    return symbolsChanged(symbols);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int length)? lengthChanged,
    TResult? Function(bool lowercase)? lowercaseChanged,
    TResult? Function(bool uppercase)? uppercaseChanged,
    TResult? Function(bool numbers)? numbersChanged,
    TResult? Function(bool symbols)? symbolsChanged,
    TResult? Function()? regeneratePassword,
  }) {
    return symbolsChanged?.call(symbols);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int length)? lengthChanged,
    TResult Function(bool lowercase)? lowercaseChanged,
    TResult Function(bool uppercase)? uppercaseChanged,
    TResult Function(bool numbers)? numbersChanged,
    TResult Function(bool symbols)? symbolsChanged,
    TResult Function()? regeneratePassword,
    required TResult orElse(),
  }) {
    if (symbolsChanged != null) {
      return symbolsChanged(symbols);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LengthChangedEvent value) lengthChanged,
    required TResult Function(LowercaseChangedEvent value) lowercaseChanged,
    required TResult Function(UppercaseChangedEvent value) uppercaseChanged,
    required TResult Function(NumbersChangedEvent value) numbersChanged,
    required TResult Function(SymbolsChangedEvent value) symbolsChanged,
    required TResult Function(RegeneratePasswordEvent value) regeneratePassword,
  }) {
    return symbolsChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LengthChangedEvent value)? lengthChanged,
    TResult? Function(LowercaseChangedEvent value)? lowercaseChanged,
    TResult? Function(UppercaseChangedEvent value)? uppercaseChanged,
    TResult? Function(NumbersChangedEvent value)? numbersChanged,
    TResult? Function(SymbolsChangedEvent value)? symbolsChanged,
    TResult? Function(RegeneratePasswordEvent value)? regeneratePassword,
  }) {
    return symbolsChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LengthChangedEvent value)? lengthChanged,
    TResult Function(LowercaseChangedEvent value)? lowercaseChanged,
    TResult Function(UppercaseChangedEvent value)? uppercaseChanged,
    TResult Function(NumbersChangedEvent value)? numbersChanged,
    TResult Function(SymbolsChangedEvent value)? symbolsChanged,
    TResult Function(RegeneratePasswordEvent value)? regeneratePassword,
    required TResult orElse(),
  }) {
    if (symbolsChanged != null) {
      return symbolsChanged(this);
    }
    return orElse();
  }
}

abstract class SymbolsChangedEvent implements GeneratorEvent {
  const factory SymbolsChangedEvent(final bool symbols) = _$SymbolsChangedEvent;

  bool get symbols;
  @JsonKey(ignore: true)
  _$$SymbolsChangedEventCopyWith<_$SymbolsChangedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RegeneratePasswordEventCopyWith<$Res> {
  factory _$$RegeneratePasswordEventCopyWith(_$RegeneratePasswordEvent value,
          $Res Function(_$RegeneratePasswordEvent) then) =
      __$$RegeneratePasswordEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RegeneratePasswordEventCopyWithImpl<$Res>
    extends _$GeneratorEventCopyWithImpl<$Res, _$RegeneratePasswordEvent>
    implements _$$RegeneratePasswordEventCopyWith<$Res> {
  __$$RegeneratePasswordEventCopyWithImpl(_$RegeneratePasswordEvent _value,
      $Res Function(_$RegeneratePasswordEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RegeneratePasswordEvent implements RegeneratePasswordEvent {
  const _$RegeneratePasswordEvent();

  @override
  String toString() {
    return 'GeneratorEvent.regeneratePassword()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RegeneratePasswordEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int length) lengthChanged,
    required TResult Function(bool lowercase) lowercaseChanged,
    required TResult Function(bool uppercase) uppercaseChanged,
    required TResult Function(bool numbers) numbersChanged,
    required TResult Function(bool symbols) symbolsChanged,
    required TResult Function() regeneratePassword,
  }) {
    return regeneratePassword();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int length)? lengthChanged,
    TResult? Function(bool lowercase)? lowercaseChanged,
    TResult? Function(bool uppercase)? uppercaseChanged,
    TResult? Function(bool numbers)? numbersChanged,
    TResult? Function(bool symbols)? symbolsChanged,
    TResult? Function()? regeneratePassword,
  }) {
    return regeneratePassword?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int length)? lengthChanged,
    TResult Function(bool lowercase)? lowercaseChanged,
    TResult Function(bool uppercase)? uppercaseChanged,
    TResult Function(bool numbers)? numbersChanged,
    TResult Function(bool symbols)? symbolsChanged,
    TResult Function()? regeneratePassword,
    required TResult orElse(),
  }) {
    if (regeneratePassword != null) {
      return regeneratePassword();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LengthChangedEvent value) lengthChanged,
    required TResult Function(LowercaseChangedEvent value) lowercaseChanged,
    required TResult Function(UppercaseChangedEvent value) uppercaseChanged,
    required TResult Function(NumbersChangedEvent value) numbersChanged,
    required TResult Function(SymbolsChangedEvent value) symbolsChanged,
    required TResult Function(RegeneratePasswordEvent value) regeneratePassword,
  }) {
    return regeneratePassword(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LengthChangedEvent value)? lengthChanged,
    TResult? Function(LowercaseChangedEvent value)? lowercaseChanged,
    TResult? Function(UppercaseChangedEvent value)? uppercaseChanged,
    TResult? Function(NumbersChangedEvent value)? numbersChanged,
    TResult? Function(SymbolsChangedEvent value)? symbolsChanged,
    TResult? Function(RegeneratePasswordEvent value)? regeneratePassword,
  }) {
    return regeneratePassword?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LengthChangedEvent value)? lengthChanged,
    TResult Function(LowercaseChangedEvent value)? lowercaseChanged,
    TResult Function(UppercaseChangedEvent value)? uppercaseChanged,
    TResult Function(NumbersChangedEvent value)? numbersChanged,
    TResult Function(SymbolsChangedEvent value)? symbolsChanged,
    TResult Function(RegeneratePasswordEvent value)? regeneratePassword,
    required TResult orElse(),
  }) {
    if (regeneratePassword != null) {
      return regeneratePassword(this);
    }
    return orElse();
  }
}

abstract class RegeneratePasswordEvent implements GeneratorEvent {
  const factory RegeneratePasswordEvent() = _$RegeneratePasswordEvent;
}
